#Time Complexity

- 시간복잡도란 문제를 해결하기 위한 연산 횟수

- 수행시간은 1억 번의 연산을 1초의 시간으로 간주

시간 복잡도 유형:

	- 빅 오메가: 최선일 때 연산 횟수
	- 빅 세타: 보통일 때 연산 횟수
	- 빅 오: 최악일 때 연산 횟수 (가장 중요! 코딩 테스트 시 염두를 해야 함)

- 다양한 테스트 케이스를 수행해 모든 케이스를 통과해야만 합격으로 판단

	- O(n!) > O(2^n) > O(n^2) > O(nlogn) > O(n) > O(logn) > O(1)
	
- 연산횟수 계산 법:

	- 연산횟수 = 알고리즘 시간 복잡도 X 데이터의 크기
	- Example: if (1 <= N <= 1,000,000 cases)
		- 버블 정렬: N^2 -> (1,000,000)^2 > 200,000,000 (부적합)
		- 병합 정렬: NlogN -> 1,000,000* log(1,000,000) < 200,000,000

- 시간 복잡도 도출 기준:

	1. 상수는 시간 복잡도 계산에서 제외
	2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준
	- Example: 3N->N | N*N->N^2

- 맞는 알고리즘을 짰을 때, 시간초과가 발생한다면 효율적이게 짰는지 봐야함.

- 코딩을 할떄는 2가지 선택해야함

	-> 알맞은 알고리즘  선택기준
	-> 비효율적인 로직 찾아서 효율적으로 교체
	=> Don't focus only on the first part.

-
	
